// Code generated by go-swagger; DO NOT EDIT.

package store_information

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// GetStoreReader is a Reader for the GetStore structure.
type GetStoreReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetStoreReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetStoreOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewGetStoreOK creates a GetStoreOK with default headers values
func NewGetStoreOK() *GetStoreOK {
	return &GetStoreOK{}
}

/*GetStoreOK handles this case with default header values.

GetStoreOK get store o k
*/
type GetStoreOK struct {
	Payload *GetStoreOKBody
}

func (o *GetStoreOK) Error() string {
	return fmt.Sprintf("[GET /store][%d] getStoreOK  %+v", 200, o.Payload)
}

func (o *GetStoreOK) GetPayload() *GetStoreOKBody {
	return o.Payload
}

func (o *GetStoreOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetStoreOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*GetStoreOKBody Store Information
swagger:model GetStoreOKBody
*/
type GetStoreOKBody struct {

	// active comparison modules
	ActiveComparisonModules []interface{} `json:"active_comparison_modules"`

	// Display address.
	Address string `json:"address,omitempty"`

	// Email address of the store administrator/owner.
	AdminEmail string `json:"admin_email,omitempty"`

	// The secure hostname of the control panel.
	ControlPanelBaseURL string `json:"control_panel_base_url,omitempty"`

	// Country where the store is located (as defined during the store sign-up process).
	Country string `json:"country,omitempty"`

	// Default currency code
	Currency string `json:"currency,omitempty"`

	// Default symbol for values in the currency.
	CurrencySymbol string `json:"currency_symbol,omitempty"`

	// Default position of the currency symbol (left or right).
	CurrencySymbolLocation string `json:"currency_symbol_location,omitempty"`

	// Default decimal places for values in the currency.
	DecimalPlaces int64 `json:"decimal_places,omitempty"`

	// Default decimal separator for values in the currency.
	DecimalSeparator string `json:"decimal_separator,omitempty"`

	// The number of decimal places.
	DimensionDecimalPlaces int64 `json:"dimension_decimal_places,omitempty"`

	// The symbol that separates the whole numbers from the decimal points.
	DimensionDecimalToken string `json:"dimension_decimal_token,omitempty"`

	// The symbol used to denote thousands.
	DimensionThousandsToken string `json:"dimension_thousands_token:,omitempty"`

	// Default dimension units (metric or imperial).
	DimensionUnits string `json:"dimension_units,omitempty"`

	// Primary domain name.
	Domain string `json:"domain,omitempty"`

	// features
	Features *GetStoreOKBodyFeatures `json:"features,omitempty"`

	// Primary contact’s first name (as defined during the store sign-up process).
	FirstName string `json:"first_name,omitempty"`

	// Unique store identifier.
	ID string `json:"id,omitempty"`

	// Industry, or vertical category, in which the business operates. (As selected from drop-down list during the store sign-up process.)
	Industry string `json:"industry,omitempty"`

	// A Boolean value that indicates whether or not prices are entered with tax.
	IsPriceEnteredWithTax bool `json:"is_price_entered_with_tax,omitempty"`

	// Default language code.
	Language string `json:"language,omitempty"`

	// Primary contact’s last name (as defined during the store sign-up process).
	LastName string `json:"last_name,omitempty"`

	// logo
	Logo *GetStoreOKBodyLogo `json:"logo,omitempty"`

	// Store's name.
	Name string `json:"name,omitempty"`

	// Email address for orders and fulfillment.
	OrderEmail string `json:"order_email,omitempty"`

	// Display phone number.
	Phone string `json:"phone,omitempty"`

	// Level of the BigCommerce plan to which this store is subscribed.
	PlanLevel string `json:"plan_level,omitempty"`

	// Name of the BigCommerce plan to which this store is subscribed.
	PlanName string `json:"plan_name,omitempty"`

	// Store’s current HTTPS URL.
	SecureURL string `json:"secure_URL,omitempty"`

	// Default thousands separator for values in the currency.
	ThousandsSeparator string `json:"thousands_separator,omitempty"`

	// timezone
	Timezone *GetStoreOKBodyTimezone `json:"timezone,omitempty"`

	// Default weight units (metric or imperial).
	WeightUnits string `json:"weight_units,omitempty"`
}

// Validate validates this get store o k body
func (o *GetStoreOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLogo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimezone(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetStoreOKBody) validateFeatures(formats strfmt.Registry) error {

	if swag.IsZero(o.Features) { // not required
		return nil
	}

	if o.Features != nil {
		if err := o.Features.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getStoreOK" + "." + "features")
			}
			return err
		}
	}

	return nil
}

func (o *GetStoreOKBody) validateLogo(formats strfmt.Registry) error {

	if swag.IsZero(o.Logo) { // not required
		return nil
	}

	if o.Logo != nil {
		if err := o.Logo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getStoreOK" + "." + "logo")
			}
			return err
		}
	}

	return nil
}

func (o *GetStoreOKBody) validateTimezone(formats strfmt.Registry) error {

	if swag.IsZero(o.Timezone) { // not required
		return nil
	}

	if o.Timezone != nil {
		if err := o.Timezone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getStoreOK" + "." + "timezone")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetStoreOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetStoreOKBody) UnmarshalBinary(b []byte) error {
	var res GetStoreOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetStoreOKBodyFeatures + `stencil_enabled`: `true` (boolean)
//     + `sitewidehttps_enabled`: `false` (boolean)
//     + `facebook_catalog_id` (string)
swagger:model GetStoreOKBodyFeatures
*/
type GetStoreOKBodyFeatures struct {

	// What type of checkout is enabled on the store. Possible values returned are optimized, single (one page), single_customizable (one page for developers), klarna.
	CheckoutType string `json:"checkout_type,omitempty"`

	// Id of the facebook catalog. If there is none, it returns an empty string.
	FacebookCatalogID string `json:"facebook_catalog_id,omitempty"`

	// Indicates if there is sitewide https.
	SitewidehttpsEnabled bool `json:"sitewidehttps_enabled,omitempty"`

	// Indicates whether a store is using a Stencil theme.
	StencilEnabled bool `json:"stencil_enabled,omitempty"`
}

// Validate validates this get store o k body features
func (o *GetStoreOKBodyFeatures) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetStoreOKBodyFeatures) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetStoreOKBodyFeatures) UnmarshalBinary(b []byte) error {
	var res GetStoreOKBodyFeatures
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetStoreOKBodyLogo get store o k body logo
swagger:model GetStoreOKBodyLogo
*/
type GetStoreOKBodyLogo struct {

	// url
	URL string `json:"url,omitempty"`
}

// Validate validates this get store o k body logo
func (o *GetStoreOKBodyLogo) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetStoreOKBodyLogo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetStoreOKBodyLogo) UnmarshalBinary(b []byte) error {
	var res GetStoreOKBodyLogo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetStoreOKBodyTimezone Time Zone
swagger:model GetStoreOKBodyTimezone
*/
type GetStoreOKBodyTimezone struct {

	// date format
	DateFormat *GetStoreOKBodyTimezoneDateFormat `json:"date_format,omitempty"`

	// a boolean indicating whether this time zone observes daylight saving time.
	DstCorrection bool `json:"dst_correction,omitempty"`

	// "-/+" offset from UTC/GMT, in seconds, during summer/daylight saving time.
	DstOffset int64 `json:"dst_offset,omitempty"`

	// a string identifying the time zone, in the format: <Continent-name>/<City-name>.
	Name string `json:"name,omitempty"`

	// a negative or positive number, identifying the offset from UTC/GMT, in seconds, during winter/standard time.
	RawOffset int64 `json:"raw_offset,omitempty"`
}

// Validate validates this get store o k body timezone
func (o *GetStoreOKBodyTimezone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDateFormat(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetStoreOKBodyTimezone) validateDateFormat(formats strfmt.Registry) error {

	if swag.IsZero(o.DateFormat) { // not required
		return nil
	}

	if o.DateFormat != nil {
		if err := o.DateFormat.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getStoreOK" + "." + "timezone" + "." + "date_format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetStoreOKBodyTimezone) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetStoreOKBodyTimezone) UnmarshalBinary(b []byte) error {
	var res GetStoreOKBodyTimezone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetStoreOKBodyTimezoneDateFormat Date Format
swagger:model GetStoreOKBodyTimezoneDateFormat
*/
type GetStoreOKBodyTimezoneDateFormat struct {

	// string that defines dates’ display format, in the pattern: M jS Y
	Display string `json:"display,omitempty"`

	// string that defines the CSV export format for orders, customers, and products, in the pattern: M jS Y
	Export string `json:"export,omitempty"`

	// string that defines dates’ extended-display format, in the pattern: M jS Y @ g:i A.
	ExtendedDisplay string `json:"extended_display,omitempty"`
}

// Validate validates this get store o k body timezone date format
func (o *GetStoreOKBodyTimezoneDateFormat) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetStoreOKBodyTimezoneDateFormat) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetStoreOKBodyTimezoneDateFormat) UnmarshalBinary(b []byte) error {
	var res GetStoreOKBodyTimezoneDateFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
