// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ScriptResponseCollection script_responseCollection
//
// For a list of all locations visit [Scripts Visibility](https://developer.bigcommerce.com/api-docs/storefront/scripts-overview#scripts_scripts-visibility).
//
// swagger:model script_responseCollection
type ScriptResponseCollection struct {

	// data
	Data []*ScriptResponseCollectionDataItems0 `json:"data"`

	// meta
	Meta *ScriptResponseCollectionMeta `json:"meta,omitempty"`
}

// Validate validates this script response collection
func (m *ScriptResponseCollection) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeta(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScriptResponseCollection) validateData(formats strfmt.Registry) error {

	if swag.IsZero(m.Data) { // not required
		return nil
	}

	for i := 0; i < len(m.Data); i++ {
		if swag.IsZero(m.Data[i]) { // not required
			continue
		}

		if m.Data[i] != nil {
			if err := m.Data[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ScriptResponseCollection) validateMeta(formats strfmt.Registry) error {

	if swag.IsZero(m.Meta) { // not required
		return nil
	}

	if m.Meta != nil {
		if err := m.Meta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("meta")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptResponseCollection) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptResponseCollection) UnmarshalBinary(b []byte) error {
	var res ScriptResponseCollection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ScriptResponseCollectionDataItems0 script_Full
//
// swagger:model ScriptResponseCollectionDataItems0
type ScriptResponseCollectionDataItems0 struct {

	// The date on which this object was initially created.
	// Format: date-time
	DateCreated strfmt.DateTime `json:"date_created,omitempty"`

	// The date on which this object was last updated.
	// Format: date-time
	DateModified strfmt.DateTime `json:"date_modified,omitempty"`

	// The primary identifier.
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// The client id of the API user that created this script, or blank if created by other means.
	APIClientID string `json:"api_client_id,omitempty"`

	// It will enable automatic cleanup of the script when the single click app is uninstalled or OAuth token is revoked.
	AutoUninstall bool `json:"auto_uninstall,omitempty"`

	// What category of script this is for the purposes of GDPR/CCPA compliance.
	// Enum: [essential functional analytics targeting]
	ConsentCategory string `json:"consent_category,omitempty"`

	// The user-friendly description.
	Description string `json:"description,omitempty"`

	// Indicates whether a script is enabled.
	Enabled bool `json:"enabled,omitempty"`

	// An html string containing exactly one `script` tag. Only present if `kind` is `script_tag`
	HTML string `json:"html,omitempty"`

	// What type of script this is.
	//
	// `src` - a `script` tag will be generated with its `src` attribute set to the value of `src`; For scripts that use the src url. By providing a path to the script, we can optimize and serve the script tag automatically for you.
	//
	// `script_tag` - The value of `html` will be injected directly onto the page.
	// For scripts which include a raw HTML script_tag to be inserted into the page. The load_method must be default.
	// Enum: [src script_tag]
	Kind string `json:"kind,omitempty"`

	// The load method to use for the script. Values are `default`, `async`, or `defer`. It determines how the script should be loaded into the page.
	// Enum: [default async defer]
	LoadMethod string `json:"load_method,omitempty"`

	// Where on the page to place the script. Values are `head` or `footer`.
	// Enum: [head footer]
	Location string `json:"location,omitempty"`

	// The `src` attribute of the script to load. Only present if `kind` is `src`.
	Src string `json:"src,omitempty"`

	// Which set of pages the script should load on.
	//
	// Please note that you need to have `Checkout content` scope to use `all_pages` and `checkout`.
	//
	// - The current visibility options are `storefront`, `checkout`, `all_pages` and `order_confirmation`.
	//
	//      `storefront`: All pages that are not `checkout` or `order_confirmation`.
	//
	// For a list of all locations visit [Scripts Visibility](https://developer.bigcommerce.com/api-docs/storefront/scripts-overview#scripts_scripts-visibility).
	// Enum: [storefront all_pages checkout order_confirmation]
	Visibility string `json:"visibility,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ScriptResponseCollectionDataItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		DateModified strfmt.DateTime `json:"date_modified,omitempty"`

		UUID strfmt.UUID `json:"uuid,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.DateCreated = dataAO0.DateCreated

	m.DateModified = dataAO0.DateModified

	m.UUID = dataAO0.UUID

	// AO1
	var dataAO1 struct {
		APIClientID string `json:"api_client_id,omitempty"`

		AutoUninstall bool `json:"auto_uninstall,omitempty"`

		ConsentCategory string `json:"consent_category,omitempty"`

		Description string `json:"description,omitempty"`

		Enabled bool `json:"enabled,omitempty"`

		HTML string `json:"html,omitempty"`

		Kind string `json:"kind,omitempty"`

		LoadMethod string `json:"load_method,omitempty"`

		Location string `json:"location,omitempty"`

		Src string `json:"src,omitempty"`

		Visibility string `json:"visibility,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.APIClientID = dataAO1.APIClientID

	m.AutoUninstall = dataAO1.AutoUninstall

	m.ConsentCategory = dataAO1.ConsentCategory

	m.Description = dataAO1.Description

	m.Enabled = dataAO1.Enabled

	m.HTML = dataAO1.HTML

	m.Kind = dataAO1.Kind

	m.LoadMethod = dataAO1.LoadMethod

	m.Location = dataAO1.Location

	m.Src = dataAO1.Src

	m.Visibility = dataAO1.Visibility

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ScriptResponseCollectionDataItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		DateModified strfmt.DateTime `json:"date_modified,omitempty"`

		UUID strfmt.UUID `json:"uuid,omitempty"`
	}

	dataAO0.DateCreated = m.DateCreated

	dataAO0.DateModified = m.DateModified

	dataAO0.UUID = m.UUID

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)
	var dataAO1 struct {
		APIClientID string `json:"api_client_id,omitempty"`

		AutoUninstall bool `json:"auto_uninstall,omitempty"`

		ConsentCategory string `json:"consent_category,omitempty"`

		Description string `json:"description,omitempty"`

		Enabled bool `json:"enabled,omitempty"`

		HTML string `json:"html,omitempty"`

		Kind string `json:"kind,omitempty"`

		LoadMethod string `json:"load_method,omitempty"`

		Location string `json:"location,omitempty"`

		Src string `json:"src,omitempty"`

		Visibility string `json:"visibility,omitempty"`
	}

	dataAO1.APIClientID = m.APIClientID

	dataAO1.AutoUninstall = m.AutoUninstall

	dataAO1.ConsentCategory = m.ConsentCategory

	dataAO1.Description = m.Description

	dataAO1.Enabled = m.Enabled

	dataAO1.HTML = m.HTML

	dataAO1.Kind = m.Kind

	dataAO1.LoadMethod = m.LoadMethod

	dataAO1.Location = m.Location

	dataAO1.Src = m.Src

	dataAO1.Visibility = m.Visibility

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this script response collection data items0
func (m *ScriptResponseCollectionDataItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsentCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateDateCreated(formats strfmt.Registry) error {

	if swag.IsZero(m.DateCreated) { // not required
		return nil
	}

	if err := validate.FormatOf("date_created", "body", "date-time", m.DateCreated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateDateModified(formats strfmt.Registry) error {

	if swag.IsZero(m.DateModified) { // not required
		return nil
	}

	if err := validate.FormatOf("date_modified", "body", "date-time", m.DateModified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateUUID(formats strfmt.Registry) error {

	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

var scriptResponseCollectionDataItems0TypeConsentCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["essential","functional","analytics","targeting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptResponseCollectionDataItems0TypeConsentCategoryPropEnum = append(scriptResponseCollectionDataItems0TypeConsentCategoryPropEnum, v)
	}
}

// property enum
func (m *ScriptResponseCollectionDataItems0) validateConsentCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptResponseCollectionDataItems0TypeConsentCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateConsentCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsentCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateConsentCategoryEnum("consent_category", "body", m.ConsentCategory); err != nil {
		return err
	}

	return nil
}

var scriptResponseCollectionDataItems0TypeKindPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["src","script_tag"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptResponseCollectionDataItems0TypeKindPropEnum = append(scriptResponseCollectionDataItems0TypeKindPropEnum, v)
	}
}

// property enum
func (m *ScriptResponseCollectionDataItems0) validateKindEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptResponseCollectionDataItems0TypeKindPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateKind(formats strfmt.Registry) error {

	if swag.IsZero(m.Kind) { // not required
		return nil
	}

	// value enum
	if err := m.validateKindEnum("kind", "body", m.Kind); err != nil {
		return err
	}

	return nil
}

var scriptResponseCollectionDataItems0TypeLoadMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","async","defer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptResponseCollectionDataItems0TypeLoadMethodPropEnum = append(scriptResponseCollectionDataItems0TypeLoadMethodPropEnum, v)
	}
}

// property enum
func (m *ScriptResponseCollectionDataItems0) validateLoadMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptResponseCollectionDataItems0TypeLoadMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateLoadMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.LoadMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateLoadMethodEnum("load_method", "body", m.LoadMethod); err != nil {
		return err
	}

	return nil
}

var scriptResponseCollectionDataItems0TypeLocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["head","footer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptResponseCollectionDataItems0TypeLocationPropEnum = append(scriptResponseCollectionDataItems0TypeLocationPropEnum, v)
	}
}

// property enum
func (m *ScriptResponseCollectionDataItems0) validateLocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptResponseCollectionDataItems0TypeLocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateLocation(formats strfmt.Registry) error {

	if swag.IsZero(m.Location) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocationEnum("location", "body", m.Location); err != nil {
		return err
	}

	return nil
}

var scriptResponseCollectionDataItems0TypeVisibilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["storefront","all_pages","checkout","order_confirmation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptResponseCollectionDataItems0TypeVisibilityPropEnum = append(scriptResponseCollectionDataItems0TypeVisibilityPropEnum, v)
	}
}

// property enum
func (m *ScriptResponseCollectionDataItems0) validateVisibilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptResponseCollectionDataItems0TypeVisibilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptResponseCollectionDataItems0) validateVisibility(formats strfmt.Registry) error {

	if swag.IsZero(m.Visibility) { // not required
		return nil
	}

	// value enum
	if err := m.validateVisibilityEnum("visibility", "body", m.Visibility); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptResponseCollectionDataItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptResponseCollectionDataItems0) UnmarshalBinary(b []byte) error {
	var res ScriptResponseCollectionDataItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ScriptResponseCollectionMeta Collection Meta
//
// Data about the response, including pagination and collection totals.
//
// swagger:model ScriptResponseCollectionMeta
type ScriptResponseCollectionMeta struct {

	// pagination
	Pagination *ScriptResponseCollectionMetaPagination `json:"pagination,omitempty"`
}

// Validate validates this script response collection meta
func (m *ScriptResponseCollectionMeta) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePagination(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScriptResponseCollectionMeta) validatePagination(formats strfmt.Registry) error {

	if swag.IsZero(m.Pagination) { // not required
		return nil
	}

	if m.Pagination != nil {
		if err := m.Pagination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("meta" + "." + "pagination")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptResponseCollectionMeta) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptResponseCollectionMeta) UnmarshalBinary(b []byte) error {
	var res ScriptResponseCollectionMeta
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ScriptResponseCollectionMetaPagination Pagination
//
// Data about the response, including pagination and collection totals.
//
// swagger:model ScriptResponseCollectionMetaPagination
type ScriptResponseCollectionMetaPagination struct {

	// Total number of items in the collection response.
	//
	Count int64 `json:"count,omitempty"`

	// The page you are currently on within the collection.
	//
	CurrentPage int64 `json:"current_page,omitempty"`

	// links
	Links *ScriptResponseCollectionMetaPaginationLinks `json:"links,omitempty"`

	// The amount of items returned in the collection per page, controlled by the limit parameter.
	//
	PerPage int64 `json:"per_page,omitempty"`

	// Total number of items in the result set.
	//
	Total int64 `json:"total,omitempty"`

	// The total number of pages in the collection.
	//
	TotalPages int64 `json:"total_pages,omitempty"`
}

// Validate validates this script response collection meta pagination
func (m *ScriptResponseCollectionMetaPagination) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScriptResponseCollectionMetaPagination) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("meta" + "." + "pagination" + "." + "links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptResponseCollectionMetaPagination) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptResponseCollectionMetaPagination) UnmarshalBinary(b []byte) error {
	var res ScriptResponseCollectionMetaPagination
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ScriptResponseCollectionMetaPaginationLinks Pagination links for the previous and next parts of the whole collection.
//
//
// swagger:model ScriptResponseCollectionMetaPaginationLinks
type ScriptResponseCollectionMetaPaginationLinks struct {

	// Link to the current page returned in the response.
	//
	Current string `json:"current,omitempty"`

	// Link to the next page returned in the response.
	//
	Next string `json:"next,omitempty"`

	// Link to the previous page returned in the response.
	//
	Previous string `json:"previous,omitempty"`
}

// Validate validates this script response collection meta pagination links
func (m *ScriptResponseCollectionMetaPaginationLinks) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ScriptResponseCollectionMetaPaginationLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptResponseCollectionMetaPaginationLinks) UnmarshalBinary(b []byte) error {
	var res ScriptResponseCollectionMetaPaginationLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
