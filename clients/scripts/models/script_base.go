// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ScriptBase script_Base
//
// Script properties common to `post`, `put`, and `get` requests.
//
// swagger:model script_Base
type ScriptBase struct {

	// The client id of the API user that created this script, or blank if created by other means.
	APIClientID string `json:"api_client_id,omitempty"`

	// It will enable automatic cleanup of the script when the single click app is uninstalled or OAuth token is revoked.
	AutoUninstall bool `json:"auto_uninstall,omitempty"`

	// What category of script this is for the purposes of GDPR/CCPA compliance.
	// Enum: [essential functional analytics targeting]
	ConsentCategory string `json:"consent_category,omitempty"`

	// The user-friendly description.
	Description string `json:"description,omitempty"`

	// Indicates whether a script is enabled.
	Enabled bool `json:"enabled,omitempty"`

	// An html string containing exactly one `script` tag. Only present if `kind` is `script_tag`
	HTML string `json:"html,omitempty"`

	// What type of script this is.
	//
	// `src` - a `script` tag will be generated with its `src` attribute set to the value of `src`; For scripts that use the src url. By providing a path to the script, we can optimize and serve the script tag automatically for you.
	//
	// `script_tag` - The value of `html` will be injected directly onto the page.
	// For scripts which include a raw HTML script_tag to be inserted into the page. The load_method must be default.
	// Enum: [src script_tag]
	Kind string `json:"kind,omitempty"`

	// The load method to use for the script. Values are `default`, `async`, or `defer`. It determines how the script should be loaded into the page.
	// Enum: [default async defer]
	LoadMethod string `json:"load_method,omitempty"`

	// Where on the page to place the script. Values are `head` or `footer`.
	// Enum: [head footer]
	Location string `json:"location,omitempty"`

	// The `src` attribute of the script to load. Only present if `kind` is `src`.
	Src string `json:"src,omitempty"`

	// Which set of pages the script should load on.
	//
	// Please note that you need to have `Checkout content` scope to use `all_pages` and `checkout`.
	//
	// - The current visibility options are `storefront`, `checkout`, `all_pages` and `order_confirmation`.
	//
	//      `storefront`: All pages that are not `checkout` or `order_confirmation`.
	//
	// For a list of all locations visit [Scripts Visibility](https://developer.bigcommerce.com/api-docs/storefront/scripts-overview#scripts_scripts-visibility).
	// Enum: [storefront all_pages checkout order_confirmation]
	Visibility string `json:"visibility,omitempty"`
}

// Validate validates this script base
func (m *ScriptBase) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConsentCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var scriptBaseTypeConsentCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["essential","functional","analytics","targeting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptBaseTypeConsentCategoryPropEnum = append(scriptBaseTypeConsentCategoryPropEnum, v)
	}
}

const (

	// ScriptBaseConsentCategoryEssential captures enum value "essential"
	ScriptBaseConsentCategoryEssential string = "essential"

	// ScriptBaseConsentCategoryFunctional captures enum value "functional"
	ScriptBaseConsentCategoryFunctional string = "functional"

	// ScriptBaseConsentCategoryAnalytics captures enum value "analytics"
	ScriptBaseConsentCategoryAnalytics string = "analytics"

	// ScriptBaseConsentCategoryTargeting captures enum value "targeting"
	ScriptBaseConsentCategoryTargeting string = "targeting"
)

// prop value enum
func (m *ScriptBase) validateConsentCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptBaseTypeConsentCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptBase) validateConsentCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsentCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateConsentCategoryEnum("consent_category", "body", m.ConsentCategory); err != nil {
		return err
	}

	return nil
}

var scriptBaseTypeKindPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["src","script_tag"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptBaseTypeKindPropEnum = append(scriptBaseTypeKindPropEnum, v)
	}
}

const (

	// ScriptBaseKindSrc captures enum value "src"
	ScriptBaseKindSrc string = "src"

	// ScriptBaseKindScriptTag captures enum value "script_tag"
	ScriptBaseKindScriptTag string = "script_tag"
)

// prop value enum
func (m *ScriptBase) validateKindEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptBaseTypeKindPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptBase) validateKind(formats strfmt.Registry) error {

	if swag.IsZero(m.Kind) { // not required
		return nil
	}

	// value enum
	if err := m.validateKindEnum("kind", "body", m.Kind); err != nil {
		return err
	}

	return nil
}

var scriptBaseTypeLoadMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","async","defer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptBaseTypeLoadMethodPropEnum = append(scriptBaseTypeLoadMethodPropEnum, v)
	}
}

const (

	// ScriptBaseLoadMethodDefault captures enum value "default"
	ScriptBaseLoadMethodDefault string = "default"

	// ScriptBaseLoadMethodAsync captures enum value "async"
	ScriptBaseLoadMethodAsync string = "async"

	// ScriptBaseLoadMethodDefer captures enum value "defer"
	ScriptBaseLoadMethodDefer string = "defer"
)

// prop value enum
func (m *ScriptBase) validateLoadMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptBaseTypeLoadMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptBase) validateLoadMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.LoadMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateLoadMethodEnum("load_method", "body", m.LoadMethod); err != nil {
		return err
	}

	return nil
}

var scriptBaseTypeLocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["head","footer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptBaseTypeLocationPropEnum = append(scriptBaseTypeLocationPropEnum, v)
	}
}

const (

	// ScriptBaseLocationHead captures enum value "head"
	ScriptBaseLocationHead string = "head"

	// ScriptBaseLocationFooter captures enum value "footer"
	ScriptBaseLocationFooter string = "footer"
)

// prop value enum
func (m *ScriptBase) validateLocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptBaseTypeLocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptBase) validateLocation(formats strfmt.Registry) error {

	if swag.IsZero(m.Location) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocationEnum("location", "body", m.Location); err != nil {
		return err
	}

	return nil
}

var scriptBaseTypeVisibilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["storefront","all_pages","checkout","order_confirmation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptBaseTypeVisibilityPropEnum = append(scriptBaseTypeVisibilityPropEnum, v)
	}
}

const (

	// ScriptBaseVisibilityStorefront captures enum value "storefront"
	ScriptBaseVisibilityStorefront string = "storefront"

	// ScriptBaseVisibilityAllPages captures enum value "all_pages"
	ScriptBaseVisibilityAllPages string = "all_pages"

	// ScriptBaseVisibilityCheckout captures enum value "checkout"
	ScriptBaseVisibilityCheckout string = "checkout"

	// ScriptBaseVisibilityOrderConfirmation captures enum value "order_confirmation"
	ScriptBaseVisibilityOrderConfirmation string = "order_confirmation"
)

// prop value enum
func (m *ScriptBase) validateVisibilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptBaseTypeVisibilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptBase) validateVisibility(formats strfmt.Registry) error {

	if swag.IsZero(m.Visibility) { // not required
		return nil
	}

	// value enum
	if err := m.validateVisibilityEnum("visibility", "body", m.Visibility); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptBase) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptBase) UnmarshalBinary(b []byte) error {
	var res ScriptBase
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
