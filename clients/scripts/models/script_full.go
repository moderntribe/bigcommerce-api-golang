// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ScriptFull script_Full
//
// swagger:model script_Full
type ScriptFull struct {

	// The date on which this object was initially created.
	// Format: date-time
	DateCreated strfmt.DateTime `json:"date_created,omitempty"`

	// The date on which this object was last updated.
	// Format: date-time
	DateModified strfmt.DateTime `json:"date_modified,omitempty"`

	// The primary identifier.
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// The client id of the API user that created this script, or blank if created by other means.
	APIClientID string `json:"api_client_id,omitempty"`

	// It will enable automatic cleanup of the script when the single click app is uninstalled or OAuth token is revoked.
	AutoUninstall bool `json:"auto_uninstall,omitempty"`

	// What category of script this is for the purposes of GDPR/CCPA compliance.
	// Enum: [essential functional analytics targeting]
	ConsentCategory string `json:"consent_category,omitempty"`

	// The user-friendly description.
	Description string `json:"description,omitempty"`

	// Indicates whether a script is enabled.
	Enabled bool `json:"enabled,omitempty"`

	// An html string containing exactly one `script` tag. Only present if `kind` is `script_tag`
	HTML string `json:"html,omitempty"`

	// What type of script this is.
	//
	// `src` - a `script` tag will be generated with its `src` attribute set to the value of `src`; For scripts that use the src url. By providing a path to the script, we can optimize and serve the script tag automatically for you.
	//
	// `script_tag` - The value of `html` will be injected directly onto the page.
	// For scripts which include a raw HTML script_tag to be inserted into the page. The load_method must be default.
	// Enum: [src script_tag]
	Kind string `json:"kind,omitempty"`

	// The load method to use for the script. Values are `default`, `async`, or `defer`. It determines how the script should be loaded into the page.
	// Enum: [default async defer]
	LoadMethod string `json:"load_method,omitempty"`

	// Where on the page to place the script. Values are `head` or `footer`.
	// Enum: [head footer]
	Location string `json:"location,omitempty"`

	// The `src` attribute of the script to load. Only present if `kind` is `src`.
	Src string `json:"src,omitempty"`

	// Which set of pages the script should load on.
	//
	// Please note that you need to have `Checkout content` scope to use `all_pages` and `checkout`.
	//
	// - The current visibility options are `storefront`, `checkout`, `all_pages` and `order_confirmation`.
	//
	//      `storefront`: All pages that are not `checkout` or `order_confirmation`.
	//
	// For a list of all locations visit [Scripts Visibility](https://developer.bigcommerce.com/api-docs/storefront/scripts-overview#scripts_scripts-visibility).
	// Enum: [storefront all_pages checkout order_confirmation]
	Visibility string `json:"visibility,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ScriptFull) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		DateModified strfmt.DateTime `json:"date_modified,omitempty"`

		UUID strfmt.UUID `json:"uuid,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.DateCreated = dataAO0.DateCreated

	m.DateModified = dataAO0.DateModified

	m.UUID = dataAO0.UUID

	// AO1
	var dataAO1 struct {
		APIClientID string `json:"api_client_id,omitempty"`

		AutoUninstall bool `json:"auto_uninstall,omitempty"`

		ConsentCategory string `json:"consent_category,omitempty"`

		Description string `json:"description,omitempty"`

		Enabled bool `json:"enabled,omitempty"`

		HTML string `json:"html,omitempty"`

		Kind string `json:"kind,omitempty"`

		LoadMethod string `json:"load_method,omitempty"`

		Location string `json:"location,omitempty"`

		Src string `json:"src,omitempty"`

		Visibility string `json:"visibility,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.APIClientID = dataAO1.APIClientID

	m.AutoUninstall = dataAO1.AutoUninstall

	m.ConsentCategory = dataAO1.ConsentCategory

	m.Description = dataAO1.Description

	m.Enabled = dataAO1.Enabled

	m.HTML = dataAO1.HTML

	m.Kind = dataAO1.Kind

	m.LoadMethod = dataAO1.LoadMethod

	m.Location = dataAO1.Location

	m.Src = dataAO1.Src

	m.Visibility = dataAO1.Visibility

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ScriptFull) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		DateModified strfmt.DateTime `json:"date_modified,omitempty"`

		UUID strfmt.UUID `json:"uuid,omitempty"`
	}

	dataAO0.DateCreated = m.DateCreated

	dataAO0.DateModified = m.DateModified

	dataAO0.UUID = m.UUID

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)
	var dataAO1 struct {
		APIClientID string `json:"api_client_id,omitempty"`

		AutoUninstall bool `json:"auto_uninstall,omitempty"`

		ConsentCategory string `json:"consent_category,omitempty"`

		Description string `json:"description,omitempty"`

		Enabled bool `json:"enabled,omitempty"`

		HTML string `json:"html,omitempty"`

		Kind string `json:"kind,omitempty"`

		LoadMethod string `json:"load_method,omitempty"`

		Location string `json:"location,omitempty"`

		Src string `json:"src,omitempty"`

		Visibility string `json:"visibility,omitempty"`
	}

	dataAO1.APIClientID = m.APIClientID

	dataAO1.AutoUninstall = m.AutoUninstall

	dataAO1.ConsentCategory = m.ConsentCategory

	dataAO1.Description = m.Description

	dataAO1.Enabled = m.Enabled

	dataAO1.HTML = m.HTML

	dataAO1.Kind = m.Kind

	dataAO1.LoadMethod = m.LoadMethod

	dataAO1.Location = m.Location

	dataAO1.Src = m.Src

	dataAO1.Visibility = m.Visibility

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this script full
func (m *ScriptFull) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsentCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScriptFull) validateDateCreated(formats strfmt.Registry) error {

	if swag.IsZero(m.DateCreated) { // not required
		return nil
	}

	if err := validate.FormatOf("date_created", "body", "date-time", m.DateCreated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScriptFull) validateDateModified(formats strfmt.Registry) error {

	if swag.IsZero(m.DateModified) { // not required
		return nil
	}

	if err := validate.FormatOf("date_modified", "body", "date-time", m.DateModified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScriptFull) validateUUID(formats strfmt.Registry) error {

	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

var scriptFullTypeConsentCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["essential","functional","analytics","targeting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptFullTypeConsentCategoryPropEnum = append(scriptFullTypeConsentCategoryPropEnum, v)
	}
}

// property enum
func (m *ScriptFull) validateConsentCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptFullTypeConsentCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptFull) validateConsentCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsentCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateConsentCategoryEnum("consent_category", "body", m.ConsentCategory); err != nil {
		return err
	}

	return nil
}

var scriptFullTypeKindPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["src","script_tag"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptFullTypeKindPropEnum = append(scriptFullTypeKindPropEnum, v)
	}
}

// property enum
func (m *ScriptFull) validateKindEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptFullTypeKindPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptFull) validateKind(formats strfmt.Registry) error {

	if swag.IsZero(m.Kind) { // not required
		return nil
	}

	// value enum
	if err := m.validateKindEnum("kind", "body", m.Kind); err != nil {
		return err
	}

	return nil
}

var scriptFullTypeLoadMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","async","defer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptFullTypeLoadMethodPropEnum = append(scriptFullTypeLoadMethodPropEnum, v)
	}
}

// property enum
func (m *ScriptFull) validateLoadMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptFullTypeLoadMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptFull) validateLoadMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.LoadMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateLoadMethodEnum("load_method", "body", m.LoadMethod); err != nil {
		return err
	}

	return nil
}

var scriptFullTypeLocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["head","footer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptFullTypeLocationPropEnum = append(scriptFullTypeLocationPropEnum, v)
	}
}

// property enum
func (m *ScriptFull) validateLocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptFullTypeLocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptFull) validateLocation(formats strfmt.Registry) error {

	if swag.IsZero(m.Location) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocationEnum("location", "body", m.Location); err != nil {
		return err
	}

	return nil
}

var scriptFullTypeVisibilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["storefront","all_pages","checkout","order_confirmation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptFullTypeVisibilityPropEnum = append(scriptFullTypeVisibilityPropEnum, v)
	}
}

// property enum
func (m *ScriptFull) validateVisibilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptFullTypeVisibilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptFull) validateVisibility(formats strfmt.Registry) error {

	if swag.IsZero(m.Visibility) { // not required
		return nil
	}

	// value enum
	if err := m.validateVisibilityEnum("visibility", "body", m.Visibility); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptFull) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptFull) UnmarshalBinary(b []byte) error {
	var res ScriptFull
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
