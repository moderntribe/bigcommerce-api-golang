// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ScriptPut script put
//
// swagger:model script_Put
type ScriptPut struct {

	// The user-friendly name.
	// Max Length: 255
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// The client id of the API user that created this script, or blank if created by other means.
	APIClientID string `json:"api_client_id,omitempty"`

	// It will enable automatic cleanup of the script when the single click app is uninstalled or OAuth token is revoked.
	AutoUninstall bool `json:"auto_uninstall,omitempty"`

	// What category of script this is for the purposes of GDPR/CCPA compliance.
	// Enum: [essential functional analytics targeting]
	ConsentCategory string `json:"consent_category,omitempty"`

	// The user-friendly description.
	Description string `json:"description,omitempty"`

	// Indicates whether a script is enabled.
	Enabled bool `json:"enabled,omitempty"`

	// An html string containing exactly one `script` tag. Only present if `kind` is `script_tag`
	HTML string `json:"html,omitempty"`

	// What type of script this is.
	//
	// `src` - a `script` tag will be generated with its `src` attribute set to the value of `src`; For scripts that use the src url. By providing a path to the script, we can optimize and serve the script tag automatically for you.
	//
	// `script_tag` - The value of `html` will be injected directly onto the page.
	// For scripts which include a raw HTML script_tag to be inserted into the page. The load_method must be default.
	// Enum: [src script_tag]
	Kind string `json:"kind,omitempty"`

	// The load method to use for the script. Values are `default`, `async`, or `defer`. It determines how the script should be loaded into the page.
	// Enum: [default async defer]
	LoadMethod string `json:"load_method,omitempty"`

	// Where on the page to place the script. Values are `head` or `footer`.
	// Enum: [head footer]
	Location string `json:"location,omitempty"`

	// The `src` attribute of the script to load. Only present if `kind` is `src`.
	Src string `json:"src,omitempty"`

	// Which set of pages the script should load on.
	//
	// Please note that you need to have `Checkout content` scope to use `all_pages` and `checkout`.
	//
	// - The current visibility options are `storefront`, `checkout`, `all_pages` and `order_confirmation`.
	//
	//      `storefront`: All pages that are not `checkout` or `order_confirmation`.
	//
	// For a list of all locations visit [Scripts Visibility](https://developer.bigcommerce.com/api-docs/storefront/scripts-overview#scripts_scripts-visibility).
	// Enum: [storefront all_pages checkout order_confirmation]
	Visibility string `json:"visibility,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ScriptPut) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name string `json:"name,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		APIClientID string `json:"api_client_id,omitempty"`

		AutoUninstall bool `json:"auto_uninstall,omitempty"`

		ConsentCategory string `json:"consent_category,omitempty"`

		Description string `json:"description,omitempty"`

		Enabled bool `json:"enabled,omitempty"`

		HTML string `json:"html,omitempty"`

		Kind string `json:"kind,omitempty"`

		LoadMethod string `json:"load_method,omitempty"`

		Location string `json:"location,omitempty"`

		Src string `json:"src,omitempty"`

		Visibility string `json:"visibility,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.APIClientID = dataAO1.APIClientID

	m.AutoUninstall = dataAO1.AutoUninstall

	m.ConsentCategory = dataAO1.ConsentCategory

	m.Description = dataAO1.Description

	m.Enabled = dataAO1.Enabled

	m.HTML = dataAO1.HTML

	m.Kind = dataAO1.Kind

	m.LoadMethod = dataAO1.LoadMethod

	m.Location = dataAO1.Location

	m.Src = dataAO1.Src

	m.Visibility = dataAO1.Visibility

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ScriptPut) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name string `json:"name,omitempty"`
	}

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)
	var dataAO1 struct {
		APIClientID string `json:"api_client_id,omitempty"`

		AutoUninstall bool `json:"auto_uninstall,omitempty"`

		ConsentCategory string `json:"consent_category,omitempty"`

		Description string `json:"description,omitempty"`

		Enabled bool `json:"enabled,omitempty"`

		HTML string `json:"html,omitempty"`

		Kind string `json:"kind,omitempty"`

		LoadMethod string `json:"load_method,omitempty"`

		Location string `json:"location,omitempty"`

		Src string `json:"src,omitempty"`

		Visibility string `json:"visibility,omitempty"`
	}

	dataAO1.APIClientID = m.APIClientID

	dataAO1.AutoUninstall = m.AutoUninstall

	dataAO1.ConsentCategory = m.ConsentCategory

	dataAO1.Description = m.Description

	dataAO1.Enabled = m.Enabled

	dataAO1.HTML = m.HTML

	dataAO1.Kind = m.Kind

	dataAO1.LoadMethod = m.LoadMethod

	dataAO1.Location = m.Location

	dataAO1.Src = m.Src

	dataAO1.Visibility = m.Visibility

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this script put
func (m *ScriptPut) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsentCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScriptPut) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", string(m.Name), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(m.Name), 255); err != nil {
		return err
	}

	return nil
}

var scriptPutTypeConsentCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["essential","functional","analytics","targeting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptPutTypeConsentCategoryPropEnum = append(scriptPutTypeConsentCategoryPropEnum, v)
	}
}

// property enum
func (m *ScriptPut) validateConsentCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptPutTypeConsentCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptPut) validateConsentCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsentCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateConsentCategoryEnum("consent_category", "body", m.ConsentCategory); err != nil {
		return err
	}

	return nil
}

var scriptPutTypeKindPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["src","script_tag"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptPutTypeKindPropEnum = append(scriptPutTypeKindPropEnum, v)
	}
}

// property enum
func (m *ScriptPut) validateKindEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptPutTypeKindPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptPut) validateKind(formats strfmt.Registry) error {

	if swag.IsZero(m.Kind) { // not required
		return nil
	}

	// value enum
	if err := m.validateKindEnum("kind", "body", m.Kind); err != nil {
		return err
	}

	return nil
}

var scriptPutTypeLoadMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","async","defer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptPutTypeLoadMethodPropEnum = append(scriptPutTypeLoadMethodPropEnum, v)
	}
}

// property enum
func (m *ScriptPut) validateLoadMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptPutTypeLoadMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptPut) validateLoadMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.LoadMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateLoadMethodEnum("load_method", "body", m.LoadMethod); err != nil {
		return err
	}

	return nil
}

var scriptPutTypeLocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["head","footer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptPutTypeLocationPropEnum = append(scriptPutTypeLocationPropEnum, v)
	}
}

// property enum
func (m *ScriptPut) validateLocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptPutTypeLocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptPut) validateLocation(formats strfmt.Registry) error {

	if swag.IsZero(m.Location) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocationEnum("location", "body", m.Location); err != nil {
		return err
	}

	return nil
}

var scriptPutTypeVisibilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["storefront","all_pages","checkout","order_confirmation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scriptPutTypeVisibilityPropEnum = append(scriptPutTypeVisibilityPropEnum, v)
	}
}

// property enum
func (m *ScriptPut) validateVisibilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scriptPutTypeVisibilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScriptPut) validateVisibility(formats strfmt.Registry) error {

	if swag.IsZero(m.Visibility) { // not required
		return nil
	}

	// value enum
	if err := m.validateVisibilityEnum("visibility", "body", m.Visibility); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptPut) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptPut) UnmarshalBinary(b []byte) error {
	var res ScriptPut
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
