// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ScriptResponse script_Response
//
// For a list of all locations visit [Scripts Visibility](https://developer.bigcommerce.com/api-docs/storefront/scripts-overview#scripts_scripts-visibility).
//
// swagger:model script_Response
type ScriptResponse struct {

	// script_Full
	Data struct {

		// The date on which this object was initially created.
		// Format: date-time
		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		// The date on which this object was last updated.
		// Format: date-time
		DateModified strfmt.DateTime `json:"date_modified,omitempty"`

		// The primary identifier.
		// Format: uuid
		UUID strfmt.UUID `json:"uuid,omitempty"`

		// The client id of the API user that created this script, or blank if created by other means.
		APIClientID string `json:"api_client_id,omitempty"`

		// It will enable automatic cleanup of the script when the single click app is uninstalled or OAuth token is revoked.
		AutoUninstall bool `json:"auto_uninstall,omitempty"`

		// What category of script this is for the purposes of GDPR/CCPA compliance.
		// Enum: [essential functional analytics targeting]
		ConsentCategory string `json:"consent_category,omitempty"`

		// The user-friendly description.
		Description string `json:"description,omitempty"`

		// Indicates whether a script is enabled.
		Enabled bool `json:"enabled,omitempty"`

		// An html string containing exactly one `script` tag. Only present if `kind` is `script_tag`
		HTML string `json:"html,omitempty"`

		// What type of script this is.
		//
		// `src` - a `script` tag will be generated with its `src` attribute set to the value of `src`; For scripts that use the src url. By providing a path to the script, we can optimize and serve the script tag automatically for you.
		//
		// `script_tag` - The value of `html` will be injected directly onto the page.
		// For scripts which include a raw HTML script_tag to be inserted into the page. The load_method must be default.
		// Enum: [src script_tag]
		Kind string `json:"kind,omitempty"`

		// The load method to use for the script. Values are `default`, `async`, or `defer`. It determines how the script should be loaded into the page.
		// Enum: [default async defer]
		LoadMethod string `json:"load_method,omitempty"`

		// Where on the page to place the script. Values are `head` or `footer`.
		// Enum: [head footer]
		Location string `json:"location,omitempty"`

		// The `src` attribute of the script to load. Only present if `kind` is `src`.
		Src string `json:"src,omitempty"`

		// Which set of pages the script should load on.
		//
		// Please note that you need to have `Checkout content` scope to use `all_pages` and `checkout`.
		//
		// - The current visibility options are `storefront`, `checkout`, `all_pages` and `order_confirmation`.
		//
		//      `storefront`: All pages that are not `checkout` or `order_confirmation`.
		//
		// For a list of all locations visit [Scripts Visibility](https://developer.bigcommerce.com/api-docs/storefront/scripts-overview#scripts_scripts-visibility).
		// Enum: [storefront all_pages checkout order_confirmation]
		Visibility string `json:"visibility,omitempty"`
	} `json:"data,omitempty"`

	// Meta
	//
	// Empty meta object; may be used later.
	Meta interface{} `json:"meta,omitempty"`
}

// Validate validates this script response
func (m *ScriptResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScriptResponse) validateData(formats strfmt.Registry) error {

	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if err := validate.FormatOf("data"+"."+"date_created", "body", "date-time", m.Data.DateCreated.String(), formats); err != nil {
		return err
	}

	if err := validate.FormatOf("data"+"."+"date_modified", "body", "date-time", m.Data.DateModified.String(), formats); err != nil {
		return err
	}

	if err := validate.FormatOf("data"+"."+"uuid", "body", "uuid", m.Data.UUID.String(), formats); err != nil {
		return err
	}

	// value enum
	if err := m.validateConsentCategoryEnum("data"+"."+"consent_category", "body", m.Data.ConsentCategory); err != nil {
		return err
	}

	// value enum
	if err := m.validateKindEnum("data"+"."+"kind", "body", m.Data.Kind); err != nil {
		return err
	}

	// value enum
	if err := m.validateLoadMethodEnum("data"+"."+"load_method", "body", m.Data.LoadMethod); err != nil {
		return err
	}

	// value enum
	if err := m.validateLocationEnum("data"+"."+"location", "body", m.Data.Location); err != nil {
		return err
	}

	// value enum
	if err := m.validateVisibilityEnum("data"+"."+"visibility", "body", m.Data.Visibility); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScriptResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScriptResponse) UnmarshalBinary(b []byte) error {
	var res ScriptResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
