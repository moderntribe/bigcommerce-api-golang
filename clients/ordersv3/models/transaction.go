// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Transaction Transaction
//
// A BigCommerce Transaction object describes a single transaction.
//
// swagger:model Transaction
type Transaction struct {

	// Amount of money in the transaction.
	//
	// Required: true
	Amount *float32 `json:"amount"`

	// Currency used for the transaction.
	//
	// Required: true
	Currency *string `json:"currency"`

	// custom
	Custom *TransactionAO0Custom `json:"custom,omitempty"`

	// The datetime of the transaction.
	//
	// Format: date-time
	DateCreated strfmt.DateTime `json:"date_created,omitempty"`

	// Store event that created the transaction.
	//
	// Required: true
	// Enum: [purchase authorization capture refund void pending settled]
	Event *string `json:"event"`

	// Result of gateway fraud review, if any. Default is `false`.
	//
	FraudReview bool `json:"fraud_review,omitempty"`

	// The payment gateway, where applicable.
	//
	// Required: true
	// Enum: [2checkout adyen amazon authorizenet bankdeposit braintree cheque cod custom firstdatagge4 giftcertificate hps instore klarna migs moneyorder nmi paypalexpress paypalpaymentsprous paypalpaymentsprouk plugnpay qbmsv2 securenet square storecredit stripe testgateway usaepay]
	Gateway *string `json:"gateway"`

	// The transaction ID returned by the payment gateway for this transaction item.
	//
	GatewayTransactionID string `json:"gateway_transaction_id,omitempty"`

	// The payment method: `credit_card` - a credit-card transaction; `electronic_wallet` - an online wallet; `store_credit` - a transaction using store credit; `gift_certificate` - a transaction using a gift certificate; `custom` - manual payment methods; `token` - payment token; `nonce` - temporary payment token; `offsite` - online payment off the site; `offline` - payment method that takes place offline.
	//
	// Required: true
	// Enum: [credit_card electronic_wallet gift_certificate store_credit apple_pay_card apple_pay_token token custom offsite offline nonce]
	Method *string `json:"method"`

	// offline
	Offline *TransactionAO0Offline `json:"offline,omitempty"`

	// The payment method ID used for this transaction
	//
	PaymentMethodID string `json:"payment_method_id,omitempty"`

	// Identifier for an existing transaction upon which this transaction acts.
	//
	ReferenceTransactionID int64 `json:"reference_transaction_id,omitempty"`

	// Status of the transaction.
	//
	// Enum: [ok error]
	Status string `json:"status,omitempty"`

	// True if the transaction performed was a test, or if the gateway is in test mode.
	//
	Test bool `json:"test,omitempty"`

	// avs result
	AvsResult *TransactionAO1AvsResult `json:"avs_result,omitempty"`

	// credit card
	CreditCard *TransactionAO1CreditCard `json:"credit_card,omitempty"`

	// cvv result
	CvvResult *TransactionAO1CvvResult `json:"cvv_result,omitempty"`

	// The datetime of the transaction.
	//
	// Format: date-time
	DateCreated strfmt.DateTime `json:"date_created,omitempty"`

	// gift certificate
	GiftCertificate *TransactionAO1GiftCertificate `json:"gift_certificate,omitempty"`

	// Unique identifier for the transaction.
	//
	ID int64 `json:"id,omitempty"`

	// Identifier for the BigCommerce Order with which this transaction is associated.
	//
	OrderID string `json:"order_id,omitempty"`

	// This field contains internal BigPay token for stored card that is then mapped to the actual third-party token. We currently do not offer a way to get third party tokens.These tokens are read-only and do not return any information about the payment.
	PaymentInstrumentToken string `json:"payment_instrument_token,omitempty"`

	// store credit
	StoreCredit *TransactionAO1StoreCredit `json:"store_credit,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *Transaction) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Amount *float32 `json:"amount"`

		Currency *string `json:"currency"`

		Custom *TransactionAO0Custom `json:"custom,omitempty"`

		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		Event *string `json:"event"`

		FraudReview bool `json:"fraud_review,omitempty"`

		Gateway *string `json:"gateway"`

		GatewayTransactionID string `json:"gateway_transaction_id,omitempty"`

		Method *string `json:"method"`

		Offline *TransactionAO0Offline `json:"offline,omitempty"`

		PaymentMethodID string `json:"payment_method_id,omitempty"`

		ReferenceTransactionID int64 `json:"reference_transaction_id,omitempty"`

		Status string `json:"status,omitempty"`

		Test bool `json:"test,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Amount = dataAO0.Amount

	m.Currency = dataAO0.Currency

	m.Custom = dataAO0.Custom

	m.DateCreated = dataAO0.DateCreated

	m.Event = dataAO0.Event

	m.FraudReview = dataAO0.FraudReview

	m.Gateway = dataAO0.Gateway

	m.GatewayTransactionID = dataAO0.GatewayTransactionID

	m.Method = dataAO0.Method

	m.Offline = dataAO0.Offline

	m.PaymentMethodID = dataAO0.PaymentMethodID

	m.ReferenceTransactionID = dataAO0.ReferenceTransactionID

	m.Status = dataAO0.Status

	m.Test = dataAO0.Test

	// AO1
	var dataAO1 struct {
		AvsResult *TransactionAO1AvsResult `json:"avs_result,omitempty"`

		CreditCard *TransactionAO1CreditCard `json:"credit_card,omitempty"`

		CvvResult *TransactionAO1CvvResult `json:"cvv_result,omitempty"`

		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		GiftCertificate *TransactionAO1GiftCertificate `json:"gift_certificate,omitempty"`

		ID int64 `json:"id,omitempty"`

		OrderID string `json:"order_id,omitempty"`

		PaymentInstrumentToken string `json:"payment_instrument_token,omitempty"`

		StoreCredit *TransactionAO1StoreCredit `json:"store_credit,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AvsResult = dataAO1.AvsResult

	m.CreditCard = dataAO1.CreditCard

	m.CvvResult = dataAO1.CvvResult

	m.DateCreated = dataAO1.DateCreated

	m.GiftCertificate = dataAO1.GiftCertificate

	m.ID = dataAO1.ID

	m.OrderID = dataAO1.OrderID

	m.PaymentInstrumentToken = dataAO1.PaymentInstrumentToken

	m.StoreCredit = dataAO1.StoreCredit

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m Transaction) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Amount *float32 `json:"amount"`

		Currency *string `json:"currency"`

		Custom *TransactionAO0Custom `json:"custom,omitempty"`

		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		Event *string `json:"event"`

		FraudReview bool `json:"fraud_review,omitempty"`

		Gateway *string `json:"gateway"`

		GatewayTransactionID string `json:"gateway_transaction_id,omitempty"`

		Method *string `json:"method"`

		Offline *TransactionAO0Offline `json:"offline,omitempty"`

		PaymentMethodID string `json:"payment_method_id,omitempty"`

		ReferenceTransactionID int64 `json:"reference_transaction_id,omitempty"`

		Status string `json:"status,omitempty"`

		Test bool `json:"test,omitempty"`
	}

	dataAO0.Amount = m.Amount

	dataAO0.Currency = m.Currency

	dataAO0.Custom = m.Custom

	dataAO0.DateCreated = m.DateCreated

	dataAO0.Event = m.Event

	dataAO0.FraudReview = m.FraudReview

	dataAO0.Gateway = m.Gateway

	dataAO0.GatewayTransactionID = m.GatewayTransactionID

	dataAO0.Method = m.Method

	dataAO0.Offline = m.Offline

	dataAO0.PaymentMethodID = m.PaymentMethodID

	dataAO0.ReferenceTransactionID = m.ReferenceTransactionID

	dataAO0.Status = m.Status

	dataAO0.Test = m.Test

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)
	var dataAO1 struct {
		AvsResult *TransactionAO1AvsResult `json:"avs_result,omitempty"`

		CreditCard *TransactionAO1CreditCard `json:"credit_card,omitempty"`

		CvvResult *TransactionAO1CvvResult `json:"cvv_result,omitempty"`

		DateCreated strfmt.DateTime `json:"date_created,omitempty"`

		GiftCertificate *TransactionAO1GiftCertificate `json:"gift_certificate,omitempty"`

		ID int64 `json:"id,omitempty"`

		OrderID string `json:"order_id,omitempty"`

		PaymentInstrumentToken string `json:"payment_instrument_token,omitempty"`

		StoreCredit *TransactionAO1StoreCredit `json:"store_credit,omitempty"`
	}

	dataAO1.AvsResult = m.AvsResult

	dataAO1.CreditCard = m.CreditCard

	dataAO1.CvvResult = m.CvvResult

	dataAO1.DateCreated = m.DateCreated

	dataAO1.GiftCertificate = m.GiftCertificate

	dataAO1.ID = m.ID

	dataAO1.OrderID = m.OrderID

	dataAO1.PaymentInstrumentToken = m.PaymentInstrumentToken

	dataAO1.StoreCredit = m.StoreCredit

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this transaction
func (m *Transaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGateway(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOffline(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvsResult(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvvResult(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGiftCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoreCredit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Transaction) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", m.Currency); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateCustom(formats strfmt.Registry) error {

	if swag.IsZero(m.Custom) { // not required
		return nil
	}

	if m.Custom != nil {
		if err := m.Custom.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("custom")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateDateCreated(formats strfmt.Registry) error {

	if swag.IsZero(m.DateCreated) { // not required
		return nil
	}

	if err := validate.FormatOf("date_created", "body", "date-time", m.DateCreated.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionTypeEventPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["purchase","authorization","capture","refund","void","pending","settled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionTypeEventPropEnum = append(transactionTypeEventPropEnum, v)
	}
}

// property enum
func (m *Transaction) validateEventEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionTypeEventPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Transaction) validateEvent(formats strfmt.Registry) error {

	if err := validate.Required("event", "body", m.Event); err != nil {
		return err
	}

	// value enum
	if err := m.validateEventEnum("event", "body", *m.Event); err != nil {
		return err
	}

	return nil
}

var transactionTypeGatewayPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["2checkout","adyen","amazon","authorizenet","bankdeposit","braintree","cheque","cod","custom","firstdatagge4","giftcertificate","hps","instore","klarna","migs","moneyorder","nmi","paypalexpress","paypalpaymentsprous","paypalpaymentsprouk","plugnpay","qbmsv2","securenet","square","storecredit","stripe","testgateway","usaepay"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionTypeGatewayPropEnum = append(transactionTypeGatewayPropEnum, v)
	}
}

// property enum
func (m *Transaction) validateGatewayEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionTypeGatewayPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Transaction) validateGateway(formats strfmt.Registry) error {

	if err := validate.Required("gateway", "body", m.Gateway); err != nil {
		return err
	}

	// value enum
	if err := m.validateGatewayEnum("gateway", "body", *m.Gateway); err != nil {
		return err
	}

	return nil
}

var transactionTypeMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["credit_card","electronic_wallet","gift_certificate","store_credit","apple_pay_card","apple_pay_token","token","custom","offsite","offline","nonce"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionTypeMethodPropEnum = append(transactionTypeMethodPropEnum, v)
	}
}

// property enum
func (m *Transaction) validateMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionTypeMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Transaction) validateMethod(formats strfmt.Registry) error {

	if err := validate.Required("method", "body", m.Method); err != nil {
		return err
	}

	// value enum
	if err := m.validateMethodEnum("method", "body", *m.Method); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateOffline(formats strfmt.Registry) error {

	if swag.IsZero(m.Offline) { // not required
		return nil
	}

	if m.Offline != nil {
		if err := m.Offline.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline")
			}
			return err
		}
	}

	return nil
}

var transactionTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionTypeStatusPropEnum = append(transactionTypeStatusPropEnum, v)
	}
}

// property enum
func (m *Transaction) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Transaction) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateAvsResult(formats strfmt.Registry) error {

	if swag.IsZero(m.AvsResult) { // not required
		return nil
	}

	if m.AvsResult != nil {
		if err := m.AvsResult.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("avs_result")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateCreditCard(formats strfmt.Registry) error {

	if swag.IsZero(m.CreditCard) { // not required
		return nil
	}

	if m.CreditCard != nil {
		if err := m.CreditCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credit_card")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateCvvResult(formats strfmt.Registry) error {

	if swag.IsZero(m.CvvResult) { // not required
		return nil
	}

	if m.CvvResult != nil {
		if err := m.CvvResult.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cvv_result")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateDateCreated(formats strfmt.Registry) error {

	if swag.IsZero(m.DateCreated) { // not required
		return nil
	}

	if err := validate.FormatOf("date_created", "body", "date-time", m.DateCreated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateGiftCertificate(formats strfmt.Registry) error {

	if swag.IsZero(m.GiftCertificate) { // not required
		return nil
	}

	if m.GiftCertificate != nil {
		if err := m.GiftCertificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gift_certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateStoreCredit(formats strfmt.Registry) error {

	if swag.IsZero(m.StoreCredit) { // not required
		return nil
	}

	if m.StoreCredit != nil {
		if err := m.StoreCredit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("store_credit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Transaction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Transaction) UnmarshalBinary(b []byte) error {
	var res Transaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TransactionAO0Custom Custom
//
// Custom payment from manual order.
//
// swagger:model TransactionAO0Custom
type TransactionAO0Custom struct {

	// Text entered for the payment method in the control panel.
	//
	PaymentMethod string `json:"payment_method,omitempty"`
}

// Validate validates this transaction a o0 custom
func (m *TransactionAO0Custom) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TransactionAO0Custom) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionAO0Custom) UnmarshalBinary(b []byte) error {
	var res TransactionAO0Custom
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TransactionAO0Offline Offline
//
// Offline payment (e.g., check or purchase order).
//
// swagger:model TransactionAO0Offline
type TransactionAO0Offline struct {

	// Display name for the offline payment.
	//
	DisplayName string `json:"display_name,omitempty"`
}

// Validate validates this transaction a o0 offline
func (m *TransactionAO0Offline) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TransactionAO0Offline) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionAO0Offline) UnmarshalBinary(b []byte) error {
	var res TransactionAO0Offline
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TransactionAO1AvsResult AVS Results
//
// Address Verification Service (AVS) result from the payment gateway.
//
// swagger:model TransactionAO1AvsResult
type TransactionAO1AvsResult struct {

	// AVS code.
	Code string `json:"code,omitempty"`

	// AVS message.
	Message string `json:"message,omitempty"`

	// AVS Code for postal matching result.
	PostalMatch string `json:"postal_match,omitempty"`

	// AVS Code for street matching result.
	StreetMatch string `json:"street_match,omitempty"`
}

// Validate validates this transaction a o1 avs result
func (m *TransactionAO1AvsResult) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TransactionAO1AvsResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionAO1AvsResult) UnmarshalBinary(b []byte) error {
	var res TransactionAO1AvsResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TransactionAO1CreditCard Credit Card
//
// A credit-card model.
//
// swagger:model TransactionAO1CreditCard
type TransactionAO1CreditCard struct {

	// The expiry month of a credit-card.
	//
	// Maximum: 12
	// Minimum: 1
	CardExpiryMonth int64 `json:"card_expiry_month,omitempty"`

	// The expiry year of a credit-card.
	//
	CardExpiryYear int64 `json:"card_expiry_year,omitempty"`

	// The IIN of a credit-card number.
	//
	CardIin string `json:"card_iin,omitempty"`

	// The last 4 digits of a credit-card number.
	//
	CardLast4 string `json:"card_last4,omitempty"`

	// **Allowed values**: alelo, alia, american_express, cabal, carnet, dankort, diners_club, discover, elo, forbrugsforeningen, jcb, maestro, master, naranja, sodexo, unionpay, visa, vr
	// Enum: [alelo alia american_express cabal carnet dankort diners_club discover elo forbrugsforeningen jcb maestro master naranja sodexo unionpay visa vr]
	CardType string `json:"card_type,omitempty"`
}

// Validate validates this transaction a o1 credit card
func (m *TransactionAO1CreditCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCardExpiryMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionAO1CreditCard) validateCardExpiryMonth(formats strfmt.Registry) error {

	if swag.IsZero(m.CardExpiryMonth) { // not required
		return nil
	}

	if err := validate.MinimumInt("credit_card"+"."+"card_expiry_month", "body", int64(m.CardExpiryMonth), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("credit_card"+"."+"card_expiry_month", "body", int64(m.CardExpiryMonth), 12, false); err != nil {
		return err
	}

	return nil
}

var transactionAO1CreditCardTypeCardTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["alelo","alia","american_express","cabal","carnet","dankort","diners_club","discover","elo","forbrugsforeningen","jcb","maestro","master","naranja","sodexo","unionpay","visa","vr"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionAO1CreditCardTypeCardTypePropEnum = append(transactionAO1CreditCardTypeCardTypePropEnum, v)
	}
}

const (

	// TransactionAO1CreditCardCardTypeAlelo captures enum value "alelo"
	TransactionAO1CreditCardCardTypeAlelo string = "alelo"

	// TransactionAO1CreditCardCardTypeAlia captures enum value "alia"
	TransactionAO1CreditCardCardTypeAlia string = "alia"

	// TransactionAO1CreditCardCardTypeAmericanExpress captures enum value "american_express"
	TransactionAO1CreditCardCardTypeAmericanExpress string = "american_express"

	// TransactionAO1CreditCardCardTypeCabal captures enum value "cabal"
	TransactionAO1CreditCardCardTypeCabal string = "cabal"

	// TransactionAO1CreditCardCardTypeCarnet captures enum value "carnet"
	TransactionAO1CreditCardCardTypeCarnet string = "carnet"

	// TransactionAO1CreditCardCardTypeDankort captures enum value "dankort"
	TransactionAO1CreditCardCardTypeDankort string = "dankort"

	// TransactionAO1CreditCardCardTypeDinersClub captures enum value "diners_club"
	TransactionAO1CreditCardCardTypeDinersClub string = "diners_club"

	// TransactionAO1CreditCardCardTypeDiscover captures enum value "discover"
	TransactionAO1CreditCardCardTypeDiscover string = "discover"

	// TransactionAO1CreditCardCardTypeElo captures enum value "elo"
	TransactionAO1CreditCardCardTypeElo string = "elo"

	// TransactionAO1CreditCardCardTypeForbrugsforeningen captures enum value "forbrugsforeningen"
	TransactionAO1CreditCardCardTypeForbrugsforeningen string = "forbrugsforeningen"

	// TransactionAO1CreditCardCardTypeJcb captures enum value "jcb"
	TransactionAO1CreditCardCardTypeJcb string = "jcb"

	// TransactionAO1CreditCardCardTypeMaestro captures enum value "maestro"
	TransactionAO1CreditCardCardTypeMaestro string = "maestro"

	// TransactionAO1CreditCardCardTypeMaster captures enum value "master"
	TransactionAO1CreditCardCardTypeMaster string = "master"

	// TransactionAO1CreditCardCardTypeNaranja captures enum value "naranja"
	TransactionAO1CreditCardCardTypeNaranja string = "naranja"

	// TransactionAO1CreditCardCardTypeSodexo captures enum value "sodexo"
	TransactionAO1CreditCardCardTypeSodexo string = "sodexo"

	// TransactionAO1CreditCardCardTypeUnionpay captures enum value "unionpay"
	TransactionAO1CreditCardCardTypeUnionpay string = "unionpay"

	// TransactionAO1CreditCardCardTypeVisa captures enum value "visa"
	TransactionAO1CreditCardCardTypeVisa string = "visa"

	// TransactionAO1CreditCardCardTypeVr captures enum value "vr"
	TransactionAO1CreditCardCardTypeVr string = "vr"
)

// prop value enum
func (m *TransactionAO1CreditCard) validateCardTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionAO1CreditCardTypeCardTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionAO1CreditCard) validateCardType(formats strfmt.Registry) error {

	if swag.IsZero(m.CardType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCardTypeEnum("credit_card"+"."+"card_type", "body", m.CardType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionAO1CreditCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionAO1CreditCard) UnmarshalBinary(b []byte) error {
	var res TransactionAO1CreditCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TransactionAO1CvvResult CVV Result
//
// Card Verification Value result from the payment gateway.
//
// swagger:model TransactionAO1CvvResult
type TransactionAO1CvvResult struct {

	// CVV code.
	Code string `json:"code,omitempty"`

	// CVV message.
	Message string `json:"message,omitempty"`
}

// Validate validates this transaction a o1 cvv result
func (m *TransactionAO1CvvResult) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TransactionAO1CvvResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionAO1CvvResult) UnmarshalBinary(b []byte) error {
	var res TransactionAO1CvvResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TransactionAO1GiftCertificate Gift Certificate
//
// A gift-certificate model.
//
// swagger:model TransactionAO1GiftCertificate
type TransactionAO1GiftCertificate struct {

	// The gift-certificate code.
	//
	Code string `json:"code,omitempty"`

	// The balance on a gift certificate when it was purchased.
	//
	OriginalBalance float32 `json:"original_balance,omitempty"`

	// The remaining balance on a gift certificate.
	//
	RemainingBalance float32 `json:"remaining_balance,omitempty"`

	// The balance on a gift certificate at the time of this purchase.
	//
	StartingBalance float32 `json:"starting_balance,omitempty"`

	// The status of a gift certificate: `active` - gift certificate is active; `pending` - gift certificate purchase is pending; `disabled` - gift certificate is disabled; `expired` - gift certificate is expired.
	//
	// Enum: [active pending disabled expired]
	Status string `json:"status,omitempty"`
}

// Validate validates this transaction a o1 gift certificate
func (m *TransactionAO1GiftCertificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var transactionAO1GiftCertificateTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","pending","disabled","expired"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionAO1GiftCertificateTypeStatusPropEnum = append(transactionAO1GiftCertificateTypeStatusPropEnum, v)
	}
}

const (

	// TransactionAO1GiftCertificateStatusActive captures enum value "active"
	TransactionAO1GiftCertificateStatusActive string = "active"

	// TransactionAO1GiftCertificateStatusPending captures enum value "pending"
	TransactionAO1GiftCertificateStatusPending string = "pending"

	// TransactionAO1GiftCertificateStatusDisabled captures enum value "disabled"
	TransactionAO1GiftCertificateStatusDisabled string = "disabled"

	// TransactionAO1GiftCertificateStatusExpired captures enum value "expired"
	TransactionAO1GiftCertificateStatusExpired string = "expired"
)

// prop value enum
func (m *TransactionAO1GiftCertificate) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionAO1GiftCertificateTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionAO1GiftCertificate) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("gift_certificate"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionAO1GiftCertificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionAO1GiftCertificate) UnmarshalBinary(b []byte) error {
	var res TransactionAO1GiftCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TransactionAO1StoreCredit A store credit model.
//
//
// swagger:model TransactionAO1StoreCredit
type TransactionAO1StoreCredit struct {

	// Remaining balance of shopper's store credit.
	//
	RemainingBalance string `json:"remaining_balance,omitempty"`
}

// Validate validates this transaction a o1 store credit
func (m *TransactionAO1StoreCredit) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TransactionAO1StoreCredit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionAO1StoreCredit) UnmarshalBinary(b []byte) error {
	var res TransactionAO1StoreCredit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
